diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/config.log elua-svn/config.log
--- elua-svn.orig/config.log	1970-01-01 01:00:00.000000000 +0100
+++ elua-svn/config.log	2010-12-31 15:27:10.815893528 +0100
@@ -0,0 +1,22 @@
+file /home/marcus/avr32/mizar/elua-svn/SConstruct,line 235:
+	Configure(confdir = .sconf_temp)
+scons: Configure: Checking whether the C compiler works
+scons: Configure: ".sconf_temp/conftest_0.c" is up to date.
+scons: Configure: The original builder output was:
+  |.sconf_temp/conftest_0.c <-
+  |  |
+  |  |int main()
+  |  |{
+  |  |    return 0;
+  |  |}
+  |  |
+  |
+scons: Configure: ".sconf_temp/conftest_0.o" is up to date.
+scons: Configure: The original builder output was:
+  |avr32-gcc -o .sconf_temp/conftest_0.o -c .sconf_temp/conftest_0.c
+  |
+scons: Configure: (cached) yes
+
+scons: Configure: error: no result
+
+
Binary files elua-svn.orig/mkfs.pyc and elua-svn/mkfs.pyc differ
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/romfs/led.lua elua-svn/romfs/led.lua
--- elua-svn.orig/romfs/led.lua	2010-12-31 14:48:16.571892093 +0100
+++ elua-svn/romfs/led.lua	2010-12-31 15:27:10.771892696 +0100
@@ -23,6 +23,9 @@ elseif pd.board() == "ATEVK1101" then
   ledpin = pio.PA_8
   invert = true  
   uartid = 1
+elseif pd.board() == "MIZAR32" then
+  ledpin = pio.PB_29
+  invert = true
 elseif pd.board() == "STR-E912" then
   ledpin = pio.P6_4
 elseif pd.board() == "ELUA-PUC" then
Binary files elua-svn.orig/.sconsign.dblite and elua-svn/.sconsign.dblite differ
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/SConstruct elua-svn/SConstruct
--- elua-svn.orig/SConstruct	2010-12-31 14:49:41.811893094 +0100
+++ elua-svn/SConstruct	2010-12-31 15:27:10.775892577 +0100
@@ -9,11 +9,11 @@ def cnorm( name ):
 
 # List of toolchains
 toolchain_list = {
-  'arm-gcc' : { 
-    'compile' : 'arm-elf-gcc', 
-    'link' : 'arm-elf-ld', 
-    'asm' : 'arm-elf-as', 
-    'bin' : 'arm-elf-objcopy', 
+  'arm-gcc' : {
+    'compile' : 'arm-elf-gcc',
+    'link' : 'arm-elf-ld',
+    'asm' : 'arm-elf-as',
+    'bin' : 'arm-elf-objcopy',
     'size' : 'arm-elf-size',
     'cross_cpumode' : 'little',
     'cross_lua' : 'float_arm 64',
@@ -29,31 +29,31 @@ toolchain_list = {
     'cross_lua' : 'float 64',
     'cross_lualong' : 'int 32'
   },
-  'codesourcery' : { 
-    'compile' : 'arm-none-eabi-gcc', 
-    'link' : 'arm-none-eabi-ld', 
-    'asm' : 'arm-none-eabi-as', 
-    'bin' : 'arm-none-eabi-objcopy', 
+  'codesourcery' : {
+    'compile' : 'arm-none-eabi-gcc',
+    'link' : 'arm-none-eabi-ld',
+    'asm' : 'arm-none-eabi-as',
+    'bin' : 'arm-none-eabi-objcopy',
     'size' : 'arm-none-eabi-size',
     'cross_cpumode' : 'little',
     'cross_lua' : 'float 64',
     'cross_lualong' : 'int 32'
   },
-  'avr32-gcc' : { 
-    'compile' : 'avr32-gcc', 
-    'link' : 'avr32-ld', 
-    'asm' : 'avr32-as', 
-    'bin' : 'avr32-objcopy', 
+  'avr32-gcc' : {
+    'compile' : 'avr32-gcc',
+    'link' : 'avr32-ld',
+    'asm' : 'avr32-as',
+    'bin' : 'avr32-objcopy',
     'size' : 'avr32-size',
     'cross_cpumode' : 'big',
     'cross_lua' : 'float 64',
     'cross_lualong' : 'int 32'
   },
-  'i686-gcc' : { 
-    'compile' : 'i686-elf-gcc', 
-    'link' : 'i686-elf-ld', 
-    'asm' : 'nasm', 
-    'bin' : 'i686-elf-objcopy', 
+  'i686-gcc' : {
+    'compile' : 'i686-elf-gcc',
+    'link' : 'i686-elf-ld',
+    'asm' : 'nasm',
+    'bin' : 'i686-elf-objcopy',
     'size' : 'i686-elf-size',
     'cross_cpumode' : 'little',
     'cross_lua' : 'float 64',
@@ -67,7 +67,7 @@ toolchain_list['devkitarm'] = toolchain_
 # List of platform/CPU/toolchains combinations
 # The first toolchain in the toolchains list is the default one
 # (the one that will be used if none is specified)
-platform_list = {  
+platform_list = {
   'at91sam7x' : { 'cpus' : [ 'AT91SAM7X256', 'AT91SAM7X512' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'lm3s' : { 'cpus' : [ 'LM3S1968', 'LM3S8962', 'LM3S6965', 'LM3S6918', 'LM3S9B92' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'str9' : { 'cpus' : [ 'STR912FAW44' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
@@ -76,7 +76,7 @@ platform_list = {  
   'lpc288x' : { 'cpus' : [ 'LPC2888' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'str7' : { 'cpus' : [ 'STR711FR2' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'stm32' : { 'cpus' : [ 'STM32F103ZE', 'STM32F103RE' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
-  'avr32' : { 'cpus' : [ 'AT32UC3A0512', 'AT32UC3B0256' ], 'toolchains' : [ 'avr32-gcc' ] },
+  'avr32' : { 'cpus' : [ 'AT32UC3A0512', 'AT32UC3A0128', 'AT32UC3B0256' ], 'toolchains' : [ 'avr32-gcc' ] },
   'lpc24xx' : { 'cpus' : [ 'LPC2468' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] },
   'lpc17xx' : { 'cpus' : [ 'LPC1768' ], 'toolchains' : [ 'arm-gcc', 'codesourcery', 'devkitarm', 'arm-eabi-gcc' ] }
 }
@@ -99,7 +99,8 @@ board_list = { 'SAM7-EX256' : [ 'AT91SAM
                'ET-STM32' : [ 'STM32F103RE' ],
                'EAGLE-100' : [ 'LM3S6918' ],
                'ELUA-PUC' : ['LPC2468' ],
-               'MBED' : ['LPC1768']
+               'MBED' : ['LPC1768'],
+               'MIZAR32' : [ 'AT32UC3A0128' ],
             }
 
 cpu_list = sum([board_list[i] for i in board_list],[])
@@ -152,6 +153,7 @@ file_list = { 'SAM7-EX256' : [ 'bisect',
               'EAGLE-100' : [ 'bisect', 'hangman', 'lhttpd', 'led', 'hello', 'info' ],
               'ELUA-PUC' : [ 'bisect', 'hangman', 'led', 'hello', 'info', 'pwmled', 'adcscope', 'adcpoll', 'inttest' ],
               'MBED' : [ 'bisect', 'hangman', 'hello', 'info', 'led', 'pwmled', 'dualpwm', 'life', 'adcscope', 'adcpoll' ],
+              'MIZAR32' : [ 'bisect', 'hangman', 'hello', 'info', 'led', 'pwmled', 'dualpwm', 'life', 'adcscope', 'adcpoll' ],
 }
 
 comp = Environment( tools = [],
@@ -172,21 +174,21 @@ class InsensitiveString(object):
   def __cmp__(self, other):
     return cmp(self.s.lower(), other.lower())
 
-def _validator(key, val, env, vals): 
-  if not val in vals: 
-    raise SCons.Errors.UserError( 
-      'Invalid value for option %s: %s' % (key, val)) 
+def _validator(key, val, env, vals):
+  if not val in vals:
+    raise SCons.Errors.UserError(
+      'Invalid value for option %s: %s' % (key, val))
 
 def MatchEnumVariable(key, help, default, allowed_values, map={}):
   help = '%s (%s)' % (help, string.join(allowed_values, '|'))
-  
+
   validator = lambda key, val, env, vals=allowed_values: \
               _validator(key, InsensitiveString(val), env, vals)
 
   converter = lambda val, map=map: \
               map.get(val, allowed_values[allowed_values.index(InsensitiveString(val))])
-  
-  return (key, help, default, validator, converter) 
+
+  return (key, help, default, validator, converter)
 
 
 # Add Configurable Variables
@@ -194,7 +196,7 @@ vars = Variables()
 
 vars.AddVariables(
   MatchEnumVariable('target',
-                    'build "regular" float lua or integer-only "lualong"', 
+                    'build "regular" float lua or integer-only "lualong"',
                     'lua',
                     allowed_values = [ 'lua', 'lualong' ] ),
   MatchEnumVariable('cpu',
@@ -301,7 +303,7 @@ if not GetOption( 'help' ):
 
   # CPU/allocator mapping (if allocator not specified)
   if comp['allocator'] == 'auto':
-    if comp['board'] in ['LPC-H2888', 'ATEVK1100', 'MBED']:
+    if comp['board'] in ['LPC-H2888', 'ATEVK1100', 'MBED', 'MIZAR32']:
       comp['allocator'] = 'multiple'
     else:
       comp['allocator'] = 'newlib'
@@ -366,7 +368,7 @@ if not GetOption( 'help' ):
     ldblib.c liolib.c lmathlib.c loslib.c ltablib.c lstrlib.c loadlib.c linit.c lua.c lrotable.c legc.c"""
 
   lua_full_files = " " + " ".join( [ "src/lua/%s" % name for name in lua_files.split() ] )
-  
+
   comp.Append(CPPPATH = ['inc', 'inc/newlib',  'inc/remotefs', 'src/platform', 'src/lua'])
   if comp['target'] == 'lualong':
     conf.env.Append(CPPDEFINES = ['LUA_NUMBER_INTEGRAL'])
@@ -413,7 +415,7 @@ if not GetOption( 'help' ):
 
   # Complete file list
   source_files = Split( app_files + specific_files + newlib_files + uip_files + lua_full_files + module_files + rfs_files )
-  
+
   comp = conf.Finish()
 
   # Make ROM File System first
@@ -426,16 +428,16 @@ if not GetOption( 'help' ):
     # Automatically includes the autorun.lua file in the ROMFS
     if os.path.isfile( os.path.join( romdir, 'autorun.lua' ) ):
       flist += [ 'autorun.lua' ]
-    # Automatically includes platform specific Lua module 
+    # Automatically includes platform specific Lua module
     if os.path.isfile( os.path.join( romdir, comp['board'] + '.lua' ) ):
       flist += [comp['board'] + '.lua']
     import mkfs
     mkfs.mkfs( romdir, "romfiles", flist, comp['romfs'], compcmd )
     print
-    if os.path.exists( "inc/romfiles.h" ): 
+    if os.path.exists( "inc/romfiles.h" ):
       os.remove( "inc/romfiles.h" )
     shutil.move( "romfiles.h", "inc/" )
-    if os.path.exists( "src/fs.o" ): 
+    if os.path.exists( "src/fs.o" ):
       os.remove( "src/fs.o" )
 
   # comp.TargetSignatures( 'content' )
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/src/platform/avr32/at32uc3a0128.ld elua-svn/src/platform/avr32/at32uc3a0128.ld
--- elua-svn.orig/src/platform/avr32/at32uc3a0128.ld	1970-01-01 01:00:00.000000000 +0100
+++ elua-svn/src/platform/avr32/at32uc3a0128.ld	2010-12-31 15:27:10.739894200 +0100
@@ -0,0 +1,51 @@
+MEMORY
+{
+    sram (W!RX) : ORIGIN = 0x00000004, LENGTH = 0x00007FFC
+    sdram (WRX) : ORIGIN = 0xd0000000, LENGTH = 32M
+    flash (RX) : ORIGIN = 0x80002000, LENGTH = 0x00020000 - 0x2000
+}
+
+SECTIONS
+{
+    .text :
+    {
+        . = ALIGN(4);
+        _stext = .;
+        PROVIDE(stext = .);
+        KEEP(*(.start))
+        *(.text .text.*)
+        *(.rodata .rodata.*)
+        *(.gnu.linkonce.t.*)
+        *(.glue_7)
+        *(.glue_7t)
+        *(.gcc_except_table)
+        *(.gnu.linkonce.r.*)
+        *(.exception .exception.*)
+        . = ALIGN(4);
+        _etext = .;
+        PROVIDE(etext = .);
+    } >sdram
+
+    .data : AT (_etext)
+    {
+        . = ALIGN(4);
+        _data = .;
+        *(.ramfunc .ramfunc.* .fastrun .fastrun.*)
+        *(.data .data.*)
+        *(.gnu.linkonce.d.*)
+        . = ALIGN(4);
+        _edata = .;
+    } >sram
+
+    .bss (NOLOAD) : {
+        _bss = .;
+        *(.bss .bss.*)
+        *(.gnu.linkonce.b.*)
+        *(COMMON)
+        . = ALIGN(4);
+        _ebss = .;
+    } >sram
+
+    end = .;
+    _sstack = 0x00008000;
+}
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/src/platform/avr32/board.h elua-svn/src/platform/avr32/board.h
--- elua-svn.orig/src/platform/avr32/board.h	2010-12-31 14:48:31.027893317 +0100
+++ elua-svn/src/platform/avr32/board.h	2010-12-31 15:27:10.739894200 +0100
@@ -65,6 +65,7 @@
 #define NGW100            7   //!< AT32AP7000 NGW100 board.
 #define STK600_RCUC3L0    8   //!< STK600 RCUC3L0 board.
 #define UC3L_EK           9   //!< AT32UC3L-EK board.
+#define MIZAR32           98  //!< Simplemachines.it MIZAR32 board.
 #define USER_BOARD        99  //!< User-reserved board (if any).
 //! @}
 
@@ -94,6 +95,8 @@
   #include "STK600/RCUC3L0/stk600_rcuc3l0.h"
 #elif BOARD == UC3L_EK
   #include "UC3L_EK/uc3l_ek.h"
+#elif BOARD == MIZAR32
+  #include "MIZAR32/mizar32.h"
 #elif BOARD == USER_BOARD
   // User-reserved area: #include the header file of your board here (if any).
   #include "user_board.h"
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/src/platform/avr32/conf.py elua-svn/src/platform/avr32/conf.py
--- elua-svn.orig/src/platform/avr32/conf.py	2010-12-31 14:48:31.015892216 +0100
+++ elua-svn/src/platform/avr32/conf.py	2010-12-31 15:27:10.739894200 +0100
@@ -9,6 +9,9 @@ if comp[ 'board' ]  == "ATEVK1100":
     comp.Append(CPPDEFINES = {'BOARD' : 1})
 elif comp[ 'board' ]  == "ATEVK1101":
     comp.Append(CPPDEFINES = {'BOARD' : 2})
+elif comp[ 'board' ]  == "MIZAR32":
+    specific_files += " sdramc.c"
+    comp.Append(CPPDEFINES = {'BOARD' : 98})
 else:
     print "Invalid board for %s platform (%s)" %( platform, comp[ 'board' ] )
     sys.exit( -1 )
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/src/platform/avr32/MIZAR32/mizar32_conf.h elua-svn/src/platform/avr32/MIZAR32/mizar32_conf.h
--- elua-svn.orig/src/platform/avr32/MIZAR32/mizar32_conf.h	1970-01-01 01:00:00.000000000 +0100
+++ elua-svn/src/platform/avr32/MIZAR32/mizar32_conf.h	2010-12-31 15:47:56.051886733 +0100
@@ -0,0 +1,153 @@
+// eLua platform configuration
+
+// Simplemachines.it Mizar32 board has 128Kbytes of flash with 8kb of bootloader
+// To fit in 120K, build using:
+// scons board=mizar32 target=lualong optram=0 allocator=newlib
+
+#ifndef __MIZAR32_CONF_H__
+#define __MIZAR32_CONF_H__
+
+#include "sdramc.h"
+
+// *****************************************************************************
+// Define here what components you want for this platform
+//~ #define BUILD_MMCFS
+//~ #define BUILD_XMODEM
+//~ #define BUILD_SHELL
+//~ #define BUILD_ROMFS
+//~ #define BUILD_TERM
+//~ #define BUILD_CON_GENERIC
+//~ #define BUILD_RPC
+//#define BUILD_MMCFS
+//#define BUILD_XMODEM
+#define BUILD_SHELL
+#define BUILD_ROMFS
+#define BUILD_TERM
+#define BUILD_CON_GENERIC
+//#define BUILD_RPC
+
+// *****************************************************************************
+// UART/Timer IDs configuration data (used in main.c)
+
+#define CON_UART_ID         0
+#define CON_UART_SPEED      115200
+#define CON_TIMER_ID        0
+#define TERM_LINES          25
+#define TERM_COLS           80
+
+// *****************************************************************************
+// SPI pins configuration data
+
+#define BOARD_SPI0_SCK_PIN                  AVR32_PIN_PA13
+#define BOARD_SPI0_SCK_PIN_FUNCTION         0
+#define BOARD_SPI0_MISO_PIN                 AVR32_PIN_PA11
+#define BOARD_SPI0_MISO_PIN_FUNCTION        0
+#define BOARD_SPI0_MOSI_PIN                 AVR32_PIN_PA12
+#define BOARD_SPI0_MOSI_PIN_FUNCTION        0
+
+#define BOARD_SPI1_SCK_PIN                  AVR32_PIN_PA15
+#define BOARD_SPI1_SCK_PIN_FUNCTION         1
+#define BOARD_SPI1_MISO_PIN                 AVR32_PIN_PA17
+#define BOARD_SPI1_MISO_PIN_FUNCTION        1
+#define BOARD_SPI1_MOSI_PIN                 AVR32_PIN_PA16
+#define BOARD_SPI1_MOSI_PIN_FUNCTION        1
+
+// Auxiliary libraries that will be compiled for this platform
+
+#if defined( BUILD_RPC ) || defined( ELUA_BOOT_RPC )
+#define RPCLINE _ROM( AUXLIB_RPC, luaopen_rpc, rpc_map )
+#else
+#define RPCLINE
+#if !defined( BUILD_RPC )
+#define BUILD_RPC
+#endif
+#endif
+
+#define LUA_PLATFORM_LIBS_ROM\
+  _ROM( AUXLIB_PD, luaopen_pd, pd_map )\
+  _ROM( AUXLIB_UART, luaopen_uart, uart_map )\
+  _ROM( AUXLIB_PIO, luaopen_pio, pio_map )\
+  _ROM( AUXLIB_TMR, luaopen_tmr, tmr_map )\
+  _ROM( AUXLIB_TERM, luaopen_term, term_map )\
+  _ROM( AUXLIB_CPU, luaopen_cpu, cpu_map )\
+  _ROM( AUXLIB_ELUA, luaopen_elua, elua_map )\
+  RPCLINE\
+  _ROM( AUXLIB_BIT, luaopen_bit, bit_map )\
+  _ROM( AUXLIB_PACK, luaopen_pack, pack_map )\
+  _ROM( LUA_MATHLIBNAME, luaopen_math, math_map )
+
+/* Minimal ROM modules, to fit in 120KB */
+#undef  LUA_PLATFORM_LIBS_ROM
+#define LUA_PLATFORM_LIBS_ROM\
+  _ROM( AUXLIB_PIO, luaopen_pio, pio_map )\
+  _ROM( AUXLIB_TMR, luaopen_tmr, tmr_map )\
+
+// *****************************************************************************
+// Configuration data
+
+// Virtual timers (0 if not used)
+#define VTMR_NUM_TIMERS       4
+#define VTMR_FREQ_HZ          4
+
+// Number of resources (0 if not available/not implemented)
+#define NUM_PIO               5
+#define NUM_SPI               8
+#define NUM_UART              2
+#if VTMR_NUM_TIMERS > 0
+#define NUM_TIMER             2
+#else
+#define NUM_TIMER             3
+#endif
+#define NUM_PWM               0
+#define NUM_ADC               0
+#define NUM_CAN               0
+
+// RPC boot options
+#define RPC_UART_ID           CON_UART_ID
+#define RPC_TIMER_ID          CON_TIMER_ID
+#define RPC_UART_SPEED        CON_UART_SPEED
+
+// On Mizar32, enabling RX buffering on UART requires the presence of a serial
+// board or a 1k resistor between pins 3 and 13 of P5; otherwise the open RX
+// input oscillates with the ambient EMI causing many spurious interrupts
+// and crashes the interpreter.  Therefore by default we disable the buffering
+// so that serial interrupts are not enabled.
+//#define BUF_ENABLE_UART
+//#define CON_BUF_SIZE          BUF_SIZE_128
+// REMEMBER to change next line if buffering is enabled and CON_UART_ID is not 0!
+//#define CON_UART_IRQ          AVR32_USART0_IRQ
+
+
+// MMCFS Support (FatFs on SD/MMC)
+// For MIZAR  - PA5 = CLK, PA6 = MISO, PA7 = MOSI, PA8 = CS
+#define MMCFS_TICK_HZ                10
+#define MMCFS_TICK_MS                ( 1000 / MMCFS_TICK_HZ )
+#define MMCFS_CS_PORT                0
+#define MMCFS_CS_PIN                 SD_MMC_SPI_NPCS_PIN
+#define MMCFS_SPI_NUM                1
+
+// CPU frequency (needed by the CPU module, 0 if not used)
+#define CPU_FREQUENCY         REQ_CPU_FREQ
+
+// PIO prefix ('0' for P0, P1, ... or 'A' for PA, PB, ...)
+#define PIO_PREFIX            'A'
+// Pins per port configuration:
+// #define PIO_PINS_PER_PORT (n) if each port has the same number of pins, or
+// #define PIO_PIN_ARRAY { n1, n2, ... } to define pins per port in an array
+// Use #define PIO_PINS_PER_PORT 0 if this isn't needed
+#define PIO_PIN_ARRAY         { 31, 32, 6, 32, 8 }
+
+// Allocator data: define your free memory zones here in two arrays
+// (start address and end address)
+// On Mizar32, we just use the 32MB SDRAM without trying to use the 8K that is
+// free in the onboard 32KB RAM, thereby simplifying the memory management.
+//#define MEM_START_ADDRESS     { ( void* )end, ( void* )SDRAM }
+//#define MEM_END_ADDRESS       { ( void* )( 0x8000 - STACK_SIZE_TOTAL - 1 ), ( void* )( SDRAM + SDRAM_SIZE - 1 ) }
+#define ELUA_FIRMWARE_SIZE 0x80000
+#define MEM_START_ADDRESS     { ( void* )SDRAM + ELUA_FIRMWARE_SIZE }
+#define MEM_END_ADDRESS       { ( void* )( SDRAM + SDRAM_SIZE - 1 ) }
+
+// *****************************************************************************
+// CPU constants that should be exposed to the eLua "cpu" module
+
+#endif // #ifndef __MIZAR32_CONF_H__
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/src/platform/avr32/MIZAR32/mizar32.h elua-svn/src/platform/avr32/MIZAR32/mizar32.h
--- elua-svn.orig/src/platform/avr32/MIZAR32/mizar32.h	1970-01-01 01:00:00.000000000 +0100
+++ elua-svn/src/platform/avr32/MIZAR32/mizar32.h	2010-12-31 15:27:10.735888588 +0100
@@ -0,0 +1,116 @@
+/* This header file was part of the ATMEL AVR-UC3-SoftwareFramework-1.6.1 Release */
+
+/*This file is prepared for Doxygen automatic documentation generation.*/
+/*! \file *********************************************************************
+ *
+ * \brief AT32UC3A MIZAR32 board header file.
+ *
+ * This file contains definitions and services related to the features of the
+ * EVK1100 board rev. B and C.
+ *
+ * To use this board, define BOARD=EVK1100.
+ *
+ * - Compiler:           IAR EWAVR32 and GNU GCC for AVR32
+ * - Supported devices:  All AVR32 AT32UC3A devices can be used.
+ * - AppNote:
+ *
+ * \author               Atmel Corporation: http://www.atmel.com \n
+ *                       Modified for MIZAR32 by Nuccio Raciti 2010
+ *
+ ******************************************************************************/
+
+/* Copyright (c) 2009 Atmel Corporation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice, this
+ * list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ * this list of conditions and the following disclaimer in the documentation
+ * and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * 4. This software may only be redistributed and used in connection with an Atmel
+ * AVR product.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE
+ *
+ */
+
+#ifndef _MIZAR32_H_
+#define _MIZAR32_H_
+
+#include "compiler.h"
+
+
+/*! \name Oscillator Definitions
+ */
+//! @{
+
+#define FOSC0           12000000                              //!< Osc0 frequency: Hz.
+#define OSC0_STARTUP    AVR32_PM_OSCCTRL0_STARTUP_2048_RCOSC  //!< Osc0 startup time: RCOsc periods.
+
+//! @}
+
+
+/*! \name SDRAM Definitions
+ */
+//! @{
+
+//! Part header file of used SDRAM(s).
+#define SDRAM_PART_HDR  "MT48LC16M16A2TG7E/mt48lc16m16a2tg7e.h"
+
+//! Data bus width to use the SDRAM(s) with (16 or 32 bits; always 16 bits on
+//! UC3).
+#define SDRAM_DBW       16
+
+//! @}
+
+
+//! Number of LEDs.
+#define LED_COUNT   1
+
+/*! \name GPIO Connections of LEDs
+ */
+//! @{
+#define LED0_GPIO   AVR32_PIN_PB29
+//! @}
+
+
+/*! \name GPIO Connections of Push Buttons
+ */
+//! @{
+#define GPIO_PUSH_BUTTON_0            AVR32_PIN_PX16
+#define GPIO_PUSH_BUTTON_0_PRESSED    0
+//! @}
+
+
+/*! \name GPIO and SPI Connections of the SD/MMC Connector
+ */
+//! @{
+#define SD_MMC_SPI                  (&AVR32_SPI1)
+#define SD_MMC_SPI_NPCS             1
+#define SD_MMC_SPI_SCK_PIN          AVR32_SPI1_SCK_0_0_PIN
+#define SD_MMC_SPI_SCK_FUNCTION     AVR32_SPI1_SCK_0_0_FUNCTION
+#define SD_MMC_SPI_MISO_PIN         AVR32_SPI1_MISO_0_0_PIN
+#define SD_MMC_SPI_MISO_FUNCTION    AVR32_SPI1_MISO_0_0_FUNCTION
+#define SD_MMC_SPI_MOSI_PIN         AVR32_SPI1_MOSI_0_0_PIN
+#define SD_MMC_SPI_MOSI_FUNCTION    AVR32_SPI1_MOSI_0_0_FUNCTION
+#define SD_MMC_SPI_NPCS_PIN         AVR32_SPI1_NPCS_1_0_PIN
+#define SD_MMC_SPI_NPCS_FUNCTION    AVR32_SPI1_NPCS_1_0_FUNCTION
+//! @}
+
+#endif  // _MIZAR32_H_
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/src/platform/avr32/platform.c elua-svn/src/platform/avr32/platform.c
--- elua-svn.orig/src/platform/avr32/platform.c	2010-12-31 14:48:31.015892216 +0100
+++ elua-svn/src/platform/avr32/platform.c	2010-12-31 15:27:10.739894200 +0100
@@ -32,6 +32,8 @@
 
 extern int pm_configure_clocks( pm_freq_param_t *param );
 
+static u32 platform_timer_set_clock( unsigned id, u32 clock );
+
 // Virtual timers support
 #if VTMR_NUM_TIMERS > 0
 #define VTMR_CH     (2)
@@ -39,19 +41,19 @@ extern int pm_configure_clocks( pm_freq_
 __attribute__((__interrupt__)) static void tmr_int_handler()
 {
   volatile avr32_tc_t *tc = &AVR32_TC;
-  
+
   tc_read_sr( tc, VTMR_CH );
   cmn_virtual_timer_cb();
-}                                
+}
 #endif
 
-static const u32 uart_base_addr[ ] = { 
-    AVR32_USART0_ADDRESS, 
-    AVR32_USART1_ADDRESS, 
-    AVR32_USART2_ADDRESS, 
+static const u32 uart_base_addr[ ] = {
+    AVR32_USART0_ADDRESS,
+    AVR32_USART1_ADDRESS,
+    AVR32_USART2_ADDRESS,
 #ifdef AVR32_USART3_ADDRESS
     AVR32_USART3_ADDRESS,
-#endif    
+#endif
 };
 
 // Buffered UART support
@@ -60,8 +62,8 @@ __attribute__((__interrupt__)) static vo
 {
   int c;
   t_buf_data temp;
-  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ CON_UART_ID ];    
-  
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ CON_UART_ID ];
+
   usart_read_char( pusart, &c );
   temp = ( t_buf_data )c;
   buf_write( BUF_ID_UART, CON_UART_ID, &temp );
@@ -77,78 +79,85 @@ int platform_init()
     REQ_CPU_FREQ,
     REQ_PBA_FREQ,
     FOSC0,
-    OSC0_STARTUP, 
+    OSC0_STARTUP,
   };
-  tc_waveform_opt_t tmropt = 
+  tc_waveform_opt_t tmropt =
   {
     0,                                 // Channel selection.
-        
+
     TC_EVT_EFFECT_NOOP,                // Software trigger effect on TIOB.
     TC_EVT_EFFECT_NOOP,                // External event effect on TIOB.
     TC_EVT_EFFECT_NOOP,                // RC compare effect on TIOB.
     TC_EVT_EFFECT_NOOP,                // RB compare effect on TIOB.
-                        
+
     TC_EVT_EFFECT_NOOP,                // Software trigger effect on TIOA.
     TC_EVT_EFFECT_NOOP,                // External event effect on TIOA.
     TC_EVT_EFFECT_NOOP,                // RC compare effect on TIOA: toggle.
     TC_EVT_EFFECT_NOOP,                // RA compare effect on TIOA: toggle (other possibilities are none, set and clear).
-                                        
+
     TC_WAVEFORM_SEL_UP_MODE,           // Waveform selection: Up mode
     FALSE,                             // External event trigger enable.
     0,                                 // External event selection.
     TC_SEL_NO_EDGE,                    // External event edge selection.
     FALSE,                             // Counter disable when RC compare.
     FALSE,                             // Counter clock stopped with RC compare.
-                                                                
+
     FALSE,                             // Burst signal selection.
     FALSE,                             // Clock inversion.
     TC_CLOCK_SOURCE_TC1                // Internal source clock 1 (32768Hz)
   };
   volatile avr32_tc_t *tc = &AVR32_TC;
   unsigned i;
-         
-  Disable_global_interrupt();  
+
+  Disable_global_interrupt();  //Already done by the bootloader (since we dont want interrupt in crt0.s), mjan 20101227
   INTC_init_interrupts();
-    
+
   // Setup clocks
+  //TODO: Clocks already set to FCPU = 60 MHz, FPBA = 15 MHz in the eLuaBLOD bootloader, Mjan 20101228
   if( PM_FREQ_STATUS_FAIL == pm_configure_clocks( &pm_freq_param ) )
-    return PLATFORM_ERR;  
+    return PLATFORM_ERR;
   // Select the 32-kHz oscillator crystal
   pm_enable_osc32_crystal (&AVR32_PM );
   // Enable the 32-kHz clock
-  pm_enable_clk32_no_wait( &AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC );    
-  
+  pm_enable_clk32_no_wait( &AVR32_PM, AVR32_PM_OSCCTRL32_STARTUP_0_RCOSC );
+
   // Initialize external memory if any.
 #ifdef AVR32_SDRAMC
-  sdramc_init( REQ_CPU_FREQ );
-#endif 
-  
+	//TODO: This is already done by the eLuaBLOD bootloader, mjan 20101227
+  //~ sdramc_init( REQ_CPU_FREQ );
+#endif
+
   // Setup UART for eLua
-  platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );  
+  platform_uart_setup( CON_UART_ID, CON_UART_SPEED, 8, PLATFORM_UART_PARITY_NONE, PLATFORM_UART_STOPBITS_1 );
 #if defined( BUF_ENABLE_UART ) && defined( CON_BUF_SIZE )
   // Enable buffering on the console UART
   buf_set( BUF_ID_UART, CON_UART_ID, CON_BUF_SIZE, BUF_DSIZE_U8 );
   // Set interrupt handler and interrupt flag on UART
-  INTC_register_interrupt( &uart_rx_handler, CON_UART_IRQ, AVR32_INTC_INT0 );  
-  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ CON_UART_ID ];      
-  pusart->ier = AVR32_USART_IER_RXRDY_MASK;  
+  INTC_register_interrupt( &uart_rx_handler, CON_UART_IRQ, AVR32_INTC_INT0 );
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ CON_UART_ID ];
+  pusart->ier = AVR32_USART_IER_RXRDY_MASK;
   Enable_global_interrupt();
 #endif
-    
+
   // Setup timers
   for( i = 0; i < 3; i ++ )
   {
     tmropt.channel = i;
     tc_init_waveform( tc, &tmropt );
+#ifndef FOSC32
+    // At reset, timers run from the 32768Hz crystal. If there is no such clock
+    // then run them all at the lowest frequency available (PBA_FREQ / 128)
+    platform_timer_set_clock( i, REQ_PBA_FREQ / 128 );
+#endif
   }
-  
+
   // Setup timer interrupt for the virtual timers if needed
 #if VTMR_NUM_TIMERS > 0
-  INTC_register_interrupt( &tmr_int_handler, AVR32_TC_IRQ2, AVR32_INTC_INT0 );  
+  INTC_register_interrupt( &tmr_int_handler, AVR32_TC_IRQ2, AVR32_INTC_INT0 );
   tmropt.channel = VTMR_CH;
   tmropt.wavsel = TC_WAVEFORM_SEL_UP_MODE_RC_TRIGGER;
   tc_init_waveform( tc, &tmropt );
-  tc_interrupt_t tmrint = 
+  tc_interrupt_t tmrint =
   {
     0,              // External trigger interrupt.
     0,              // RB load interrupt.
@@ -159,10 +168,19 @@ int platform_init()
     0,              // Load overrun interrupt.
     0               // Counter overflow interrupt.
   };
-  tc_write_rc( tc, VTMR_CH, 32768 / VTMR_FREQ_HZ );
+# ifdef FOSC32
+  tc_write_rc( tc, VTMR_CH, FOSC32 / VTMR_FREQ_HZ );
+# else
+  // Run VTMR from the slowest available PBA clock divisor
+  { u32 vt_clock_freq = platform_timer_set_clock( VTMR_CH, REQ_PBA_FREQ / 128 );
+    u32 div = vt_clock_freq / VTMR_FREQ_HZ;
+    if (div > 0xffff) div = 0xffff;
+    tc_write_rc( tc, VTMR_CH, div );
+  }
+# endif
   tc_configure_interrupts( tc, VTMR_CH, &tmrint );
   Enable_global_interrupt();
-  tc_start( tc, VTMR_CH );  
+  tc_start( tc, VTMR_CH );
 #endif
 
     // Setup spi controller(s) : up to 4 slave by controller.
@@ -172,35 +190,35 @@ int platform_init()
     spiopt.pcs_decode = FALSE;
     spiopt.delay = 0;
     spi_initMaster(&AVR32_SPI0, &spiopt, REQ_PBA_FREQ);
-    
+
 #if NUM_SPI > 4
     spi_initMaster(&AVR32_SPI1, &spiopt, REQ_PBA_FREQ);
-#endif    
+#endif
 
 #endif
 
   cmn_platform_init();
-    
-  // All done  
+
+  // All done
   return PLATFORM_OK;
-} 
+}
 
 // ****************************************************************************
 // PIO functions
 
 /* Note about AVR32 GPIO
-PIOs on AVR32 are a weird deal. They aren't really organized in ports, but 
+PIOs on AVR32 are a weird deal. They aren't really organized in ports, but
 rather they are numbered from 0 to a maximum number (which also give the total
-number of GPIOs in the system) then you do operations on that pin number. 
+number of GPIOs in the system) then you do operations on that pin number.
 We need to organize this in ports though, so here's our organization:
 PA: 31 bits, direct mapping to AVR GPIO0 ... GPIO30
 PB: 32 bits, direct mapping to AVR GPIO32 ... GPIO63
 PC: 6 bits, direct mapping to AVR GPIO64 ... GPIO69
 PX: this is where all hell breaks loose. PX seems to be a quite random mapping
-between the rest of the GPIOs and some "port" that has 40 bits and a very 
+between the rest of the GPIOs and some "port" that has 40 bits and a very
 imaginative mapping to the GPIOs (PX0 is GPIO100, PX1 is GPIO99, PX2 is GPIO98 ...
 and PX11 is GPIO109, just to give a few examples). So let's make some sense out of
-this. We define two pseudo ports: a 32 bits one (GPIO70-GPIO101) and an 8 bits one 
+this. We define two pseudo ports: a 32 bits one (GPIO70-GPIO101) and an 8 bits one
 (GPIO102-GPIO109).
 PD: 32 bits, GPIO70-GPIO101
 PE:  8 bits, GPIO102-GPIO109
@@ -228,7 +246,7 @@ on the hardware ports (PA, PB, PC).
 static volatile unsigned long* platform_pio_get_port_reg_addr( unsigned port, int regtype )
 {
   volatile avr32_gpio_port_t *gpio_port = &GPIO.port[ port ];
-  
+
   switch( regtype )
   {
     case PIO_REG_PVR:
@@ -251,24 +269,24 @@ static pio_type platform_pio_get_port_re
 {
   pio_type v;
   volatile unsigned long *pv = platform_pio_get_port_reg_addr( port, reg );
-  
+
   switch( port )
   {
     case PA:   // PA - 31 bits
       return *pv & 0x7FFFFFFF;
-      
+
     case PB:   // PB - 32 bits
       return *pv;
-      
+
     case PC:   // PC - 6 bits
-      return *pv & 0x3F;      
-      
+      return *pv & 0x3F;
+
     case PD:   // PD - pseudo port (70-101, has 26 bits on P2 and 6 bits on P3)
       pv = platform_pio_get_port_reg_addr( 2, reg );
       v = ( *pv & 0xFFFFFFC0 ) >> 6;
       pv = platform_pio_get_port_reg_addr( 3, reg );
       return ( ( *pv & 0x3F ) << 26 ) | v;
-      
+
     case PE:   // PE - pseudo port (102-109, 8 bits on P3)
       pv = platform_pio_get_port_reg_addr( 3, reg );
       return ( *pv & 0x3FC0 ) >> 6;
@@ -281,31 +299,31 @@ static pio_type platform_pio_get_port_re
 static void platform_pio_set_port_reg( unsigned port, pio_type val, int reg )
 {
   volatile unsigned long *pv = platform_pio_get_port_reg_addr( port, reg );
-    
+
   switch( port )
   {
     case PA:   // PA - 31 bits
       *pv = val & 0x7FFFFFFF;
       break;
-            
+
     case PB:   // PB - 32 bits
       *pv = val;
       break;
-      
+
     case PC:   // PC - 6 bits
       *pv = ( *pv & ~0x3F ) | ( val & 0x3F );
       break;
-      
+
     case PD:  // PD - pseudo port (70-101, has 26 bits on P2 and 6 bits on P3)
       pv = platform_pio_get_port_reg_addr( 2, reg );
       *pv = ( *pv & ~0xFFFFFFC0 ) | ( val << 6 );
       pv = platform_pio_get_port_reg_addr( 3, reg );
       *pv = ( *pv & ~0x3F ) | ( val >> 26 );
       break;
-    
+
     case PE:  // PE - pseudo port (102-109, 8 bits on P3)
       pv = platform_pio_get_port_reg_addr( 3, reg );
-      *pv = ( *pv & ~0x3FC0 ) | ( ( val & 0xFF ) << 6 );   
+      *pv = ( *pv & ~0x3FC0 ) | ( ( val & 0xFF ) << 6 );
       break;
   }
 }
@@ -313,51 +331,51 @@ static void platform_pio_set_port_reg( u
 pio_type platform_pio_op( unsigned port, pio_type pinmask, int op )
 {
   pio_type retval = 1;
-  
+
   switch( op )
   {
-    case PLATFORM_IO_PORT_SET_VALUE:    
+    case PLATFORM_IO_PORT_SET_VALUE:
       platform_pio_set_port_reg( port, pinmask, PIO_REG_OVR );
       break;
-      
+
     case PLATFORM_IO_PIN_SET:
       platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_OVR ) | pinmask, PIO_REG_OVR );
       break;
-      
+
     case PLATFORM_IO_PIN_CLEAR:
       platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_OVR ) & ~pinmask, PIO_REG_OVR );
       break;
-      
+
     case PLATFORM_IO_PORT_DIR_INPUT:
-      pinmask = 0xFFFFFFFF;      
+      pinmask = 0xFFFFFFFF;
     case PLATFORM_IO_PIN_DIR_INPUT:
       platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_ODER ) & ~pinmask, PIO_REG_ODER );
       platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_GPER ) | pinmask, PIO_REG_GPER );
       break;
-      
-    case PLATFORM_IO_PORT_DIR_OUTPUT:      
+
+    case PLATFORM_IO_PORT_DIR_OUTPUT:
       pinmask = 0xFFFFFFFF;
     case PLATFORM_IO_PIN_DIR_OUTPUT:
       platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_ODER ) | pinmask, PIO_REG_ODER );
-      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_GPER ) | pinmask, PIO_REG_GPER );    
-      break;      
-            
+      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_GPER ) | pinmask, PIO_REG_GPER );
+      break;
+
     case PLATFORM_IO_PORT_GET_VALUE:
       retval = platform_pio_get_port_reg( port, pinmask == PLATFORM_IO_READ_IN_MASK ? PIO_REG_PVR : PIO_REG_OVR );
       break;
-      
+
     case PLATFORM_IO_PIN_GET:
       retval = platform_pio_get_port_reg( port, PIO_REG_PVR ) & pinmask ? 1 : 0;
       break;
-      
+
     case PLATFORM_IO_PIN_PULLUP:
       platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_PUER ) | pinmask, PIO_REG_PUER );
       break;
-      
+
     case PLATFORM_IO_PIN_NOPULL:
-      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_PUER ) & ~pinmask, PIO_REG_PUER );    
+      platform_pio_set_port_reg( port, platform_pio_get_port_reg( port, PIO_REG_PUER ) & ~pinmask, PIO_REG_PUER );
       break;
-      
+
     default:
       retval = 0;
       break;
@@ -369,70 +387,70 @@ pio_type platform_pio_op( unsigned port,
 // UART functions
 
 
-static const gpio_map_t uart_pins = 
+static const gpio_map_t uart_pins =
 {
   // UART 0
   { AVR32_USART0_RXD_0_0_PIN, AVR32_USART0_RXD_0_0_FUNCTION },
   { AVR32_USART0_TXD_0_0_PIN, AVR32_USART0_TXD_0_0_FUNCTION },
-  
+
   // UART 1
   { AVR32_USART1_RXD_0_0_PIN, AVR32_USART1_RXD_0_0_FUNCTION },
   { AVR32_USART1_TXD_0_0_PIN, AVR32_USART1_TXD_0_0_FUNCTION },
-  
+
   // UART 2
   { AVR32_USART2_RXD_0_0_PIN, AVR32_USART2_RXD_0_0_FUNCTION },
   { AVR32_USART2_TXD_0_0_PIN, AVR32_USART2_TXD_0_0_FUNCTION },
-  
-#ifdef AVR32_USART3_ADDRESS  
+
+#ifdef AVR32_USART3_ADDRESS
   // UART 3
   { AVR32_USART3_RXD_0_0_PIN, AVR32_USART3_RXD_0_0_FUNCTION },
   { AVR32_USART3_TXD_0_0_PIN, AVR32_USART3_TXD_0_0_FUNCTION },
-#endif  
+#endif
 };
 
 u32 platform_uart_setup( unsigned id, u32 baud, int databits, int parity, int stopbits )
 {
-  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];  
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];
   usart_options_t opts;
-  
+
   opts.channelmode = USART_NORMAL_CHMODE;
   opts.charlength = databits;
   opts.baudrate = baud;
-  
+
   // Set stopbits
   if( stopbits == PLATFORM_UART_STOPBITS_1 )
     opts.stopbits = USART_1_STOPBIT;
   else if( stopbits == PLATFORM_UART_STOPBITS_1_5 )
     opts.stopbits = USART_1_5_STOPBITS;
   else
-    opts.stopbits = USART_2_STOPBITS;    
-    
+    opts.stopbits = USART_2_STOPBITS;
+
   // Set parity
   if( parity == PLATFORM_UART_PARITY_EVEN )
     opts.paritytype = USART_EVEN_PARITY;
   else if( parity == PLATFORM_UART_PARITY_ODD )
     opts.paritytype = USART_ODD_PARITY;
   else
-    opts.paritytype = USART_NO_PARITY;  
-    
+    opts.paritytype = USART_NO_PARITY;
+
   // Set actual interface
   gpio_enable_module(uart_pins + id * 2, 2 );
-  usart_init_rs232( pusart, &opts, REQ_PBA_FREQ );  
-  
+  usart_init_rs232( pusart, &opts, REQ_PBA_FREQ );
+
   // [TODO] Return actual baud here
   return baud;
 }
 
 void platform_uart_send( unsigned id, u8 data )
 {
-  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];  
-  
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];
+
   usart_putchar( pusart, data );
-}    
+}
 
 int platform_s_uart_recv( unsigned id, s32 timeout )
 {
-  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];  
+  volatile avr32_usart_t *pusart = ( volatile avr32_usart_t* )uart_base_addr[ id ];
   int temp;
 
   if( timeout == 0 )
@@ -456,8 +474,12 @@ static u32 platform_timer_get_clock( uns
 {
   volatile avr32_tc_t *tc = &AVR32_TC;
   unsigned int clksel = tc->channel[ id ].CMR.waveform.tcclks;
-        
-  return clksel == 0 ? 32768 : REQ_PBA_FREQ / clkdivs[ clksel ];
+
+#ifdef FOSC32
+  return clksel == 0 ? FOSC32 : REQ_PBA_FREQ / clkdivs[ clksel ];
+#else
+  return REQ_PBA_FREQ / clkdivs[ clksel ];
+#endif
 }
 
 // Helper: set timer clock
@@ -466,22 +488,33 @@ static u32 platform_timer_set_clock( uns
   unsigned i, mini;
   volatile avr32_tc_t *tc = &AVR32_TC;
   volatile unsigned long *pclksel = &tc->channel[ id ].cmr;
-  
+
+#ifdef FOSC32
   for( i = mini = 0; i < 5; i ++ )
-    if( ABSDIFF( clock, i == 0 ? 32768 : REQ_PBA_FREQ / clkdivs[ i ] ) < ABSDIFF( clock, mini == 0 ? 32768 : REQ_PBA_FREQ / clkdivs[ mini ] ) )
+    if( ABSDIFF( clock, i == 0 ? FOSC32 : REQ_PBA_FREQ / clkdivs[ i ] ) <
+        ABSDIFF( clock, mini == 0 ? FOSC32 : REQ_PBA_FREQ / clkdivs[ mini ] ) )
       mini = i;
   *pclksel = ( *pclksel & ~0x07 ) | mini;
-  return mini == 0 ? 32768 : REQ_PBA_FREQ / clkdivs[ mini ];
+  return mini == 0 ? FOSC32 : REQ_PBA_FREQ / clkdivs[ mini ];
+#else
+  // There is no 32768Hz clock so choose from the divisors of PBA.
+  for( i = mini = 1; i < 5; i ++ )
+    if( ABSDIFF( clock, REQ_PBA_FREQ / clkdivs[ i ] ) <
+        ABSDIFF( clock, REQ_PBA_FREQ / clkdivs[ mini ] ) )
+      mini = i;
+  *pclksel = ( *pclksel & ~0x07 ) | mini;
+  return REQ_PBA_FREQ / clkdivs[ mini ];
+#endif
 }
 
 void platform_s_timer_delay( unsigned id, u32 delay_us )
 {
-  volatile avr32_tc_t *tc = &AVR32_TC;  
+  volatile avr32_tc_t *tc = &AVR32_TC;
   u32 freq;
   timer_data_type final;
   volatile int i;
   volatile const avr32_tc_sr_t *sr = &tc->channel[ id ].SR;
-      
+
   freq = platform_timer_get_clock( id );
   final = ( ( u64 )delay_us * freq ) / 1000000;
   if( final > 0xFFFF )
@@ -489,39 +522,39 @@ void platform_s_timer_delay( unsigned id
   tc_start( tc, id );
   i = sr->covfs;
   for( i = 0; i < 200; i ++ );
-  while( ( tc_read_tc( tc, id ) < final ) && !sr->covfs );  
+  while( ( tc_read_tc( tc, id ) < final ) && !sr->covfs );
 }
 
 u32 platform_s_timer_op( unsigned id, int op, u32 data )
 {
   u32 res = 0;
   volatile int i;
-  volatile avr32_tc_t *tc = &AVR32_TC;    
-  
+  volatile avr32_tc_t *tc = &AVR32_TC;
+
   switch( op )
   {
     case PLATFORM_TIMER_OP_START:
       res = 0;
       tc_start( tc, id );
-      for( i = 0; i < 200; i ++ );      
+      for( i = 0; i < 200; i ++ );
       break;
-      
+
     case PLATFORM_TIMER_OP_READ:
       res = tc_read_tc( tc, id );
       break;
-      
+
     case PLATFORM_TIMER_OP_GET_MAX_DELAY:
       res = platform_timer_get_diff_us( id, 0, 0xFFFF );
       break;
-      
+
     case PLATFORM_TIMER_OP_GET_MIN_DELAY:
       res = platform_timer_get_diff_us( id, 0, 1 );
-      break;      
-      
+      break;
+
     case PLATFORM_TIMER_OP_SET_CLOCK:
       res = platform_timer_set_clock( id, data );
       break;
-      
+
     case PLATFORM_TIMER_OP_GET_CLOCK:
       res = platform_timer_get_clock( id );
       break;
@@ -535,30 +568,30 @@ u32 platform_s_timer_op( unsigned id, in
 /* Note about AVR32 SPI
  *
  * Each controller can handle up to 4 different settings.
- * Here, for convenience, we don't use the builtin chip select lines, 
+ * Here, for convenience, we don't use the builtin chip select lines,
  * it's up to the user to drive the corresponding GPIO lines.
  *
 */
-static const gpio_map_t spi_pins = 
+static const gpio_map_t spi_pins =
 {
   // SPI0
   { BOARD_SPI0_SCK_PIN, BOARD_SPI0_SCK_PIN_FUNCTION },
   { BOARD_SPI0_MISO_PIN, BOARD_SPI0_MISO_PIN_FUNCTION },
   { BOARD_SPI0_MOSI_PIN, BOARD_SPI0_MOSI_PIN_FUNCTION },
-  
+
   // SPI1
-#if NUM_SPI > 4  
+#if NUM_SPI > 4
   { BOARD_SPI1_SCK_PIN, BOARD_SPI1_SCK_PIN_FUNCTION },
   { BOARD_SPI1_MISO_PIN, BOARD_SPI1_MISO_PIN_FUNCTION },
   { BOARD_SPI1_MOSI_PIN, BOARD_SPI1_MOSI_PIN_FUNCTION },
-#endif  
+#endif
 };
 
 static const
-u32 spireg[] = 
-{ 
-    AVR32_SPI0_ADDRESS, 
-#ifdef AVR32_SPI1_ADDRESS    
+u32 spireg[] =
+{
+    AVR32_SPI0_ADDRESS,
+#ifdef AVR32_SPI1_ADDRESS
     AVR32_SPI1_ADDRESS,
 #endif
 };
@@ -566,7 +599,7 @@ u32 spireg[] = 
 u32 platform_spi_setup( unsigned id, int mode, u32 clock, unsigned cpol, unsigned cpha, unsigned databits )
 {
     spi_options_t opt;
-    
+
     opt.baudrate = clock;
     opt.bits = min(databits, 16);
     opt.spck_delay = 0;
@@ -576,7 +609,7 @@ u32 platform_spi_setup( unsigned id, int
     // Set actual interface
     gpio_enable_module(spi_pins + (id >> 2) * 3, 3);
     spi_setupChipReg((volatile avr32_spi_t *) spireg[id >> 2], id % 4, &opt, REQ_PBA_FREQ);
-    
+
     // TODO: return the actual baudrate.
     return clock;
 }
@@ -584,9 +617,9 @@ u32 platform_spi_setup( unsigned id, int
 spi_data_type platform_spi_send_recv( unsigned id, spi_data_type data )
 {
     volatile avr32_spi_t * spi = (volatile avr32_spi_t *) spireg[id >> 2];
-    
+
     /* Since none of the builtin chip select lines are externally wired,
-     * spi_selectChip() just ensure that the correct spi settings are 
+     * spi_selectChip() just ensure that the correct spi settings are
      * used for the transfer.
      */
     spi_selectChip(spi, id % 4);
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/src/platform/avr32/platform_conf.h elua-svn/src/platform/avr32/platform_conf.h
--- elua-svn.orig/src/platform/avr32/platform_conf.h	2010-12-31 14:48:31.015892216 +0100
+++ elua-svn/src/platform/avr32/platform_conf.h	2010-12-31 15:27:10.739894200 +0100
@@ -11,6 +11,8 @@
     #include "EVK1100/evk1100_conf.h"
 #elif BOARD == EVK1101
     #include "EVK1101/evk1101_conf.h"
+#elif BOARD == MIZAR32
+    #include "MIZAR32/mizar32_conf.h"
 #else
     #error No known AVR32 board defined    
 #endif
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/src/platform/avr32/pm_conf_clocks.c elua-svn/src/platform/avr32/pm_conf_clocks.c
--- elua-svn.orig/src/platform/avr32/pm_conf_clocks.c	2010-12-31 14:48:31.027893317 +0100
+++ elua-svn/src/platform/avr32/pm_conf_clocks.c	2010-12-31 15:27:10.739894200 +0100
@@ -72,8 +72,10 @@ int pm_configure_clocks(pm_freq_param_t 
   //  12   15   1  192     1     48    12
   //  12   15   1  192     1     48    24
   //  12    8   1  108     1     54    27
+
   //  12    9   1  120     1     60    15
   //  12    9   1  120     1     60    30
+
   //  12   10   1  132     1     66    16.5
   //
   unsigned long in_cpu_f  = param->cpu_f;
@@ -82,8 +84,9 @@ int pm_configure_clocks(pm_freq_param_t 
   unsigned long pll_freq, rest;
   Bool b_div2_pba, b_div2_cpu;
 
+	//PLL0 is already set up and running by the eLuaBLOD bootloader, we skip this part here, mjan 20101227
   // Switch to external Oscillator 0
-  pm_switch_to_osc0(&AVR32_PM, in_osc0_f, param->osc0_startup);
+  //~ pm_switch_to_osc0(&AVR32_PM, in_osc0_f, param->osc0_startup);
 
   // Start with CPU freq config
   if (in_cpu_f == in_osc0_f)
@@ -143,21 +146,21 @@ int pm_configure_clocks(pm_freq_param_t 
   param->cpu_f = pll_freq / (1 << div2_cpu);
   mul--;
 
-  pm_pll_setup(&AVR32_PM
-  , 0   // pll
-  , mul // mul
-  , div // div
-  , 0   // osc
-  , 16  // lockcount
-  );
-
-  pm_pll_set_option(&AVR32_PM
-  , 0 // pll
-  // PLL clock is lower than 160MHz: need to set pllopt.
-  , (pll_freq < AVR32_PM_PLL_VCO_RANGE0_MIN_FREQ) ? 1 : 0 // pll_freq
-  , div2_en // pll_div2
-  , 0 // pll_wbwdisable
-  );
+	//PLL0 is already set up by the eLuaBLOD bootloader, we skip this part here, mjan 20101227
+  //~ pm_pll_setup(&AVR32_PM
+  //~ , 0   // pll
+  //~ , mul // mul
+  //~ , div // div
+  //~ , 0   // osc
+  //~ , 16  // lockcount
+  //~ );
+  //~ pm_pll_set_option(&AVR32_PM
+  //~ , 0 // pll
+  //~ // PLL clock is lower than 160MHz: need to set pllopt.
+  //~ , (pll_freq < AVR32_PM_PLL_VCO_RANGE0_MIN_FREQ) ? 1 : 0 // pll_freq
+  //~ , div2_en // pll_div2
+  //~ , 0 // pll_wbwdisable
+  //~ );
 
   rest = pll_freq;
   while (rest > AVR32_PM_PBA_MAX_FREQ ||
@@ -172,11 +175,11 @@ int pm_configure_clocks(pm_freq_param_t 
   // Update real PBA Frequency
   param->pba_f = pll_freq / (1 << div2_pba);
 
+	//PLL0 is already enabled by the eLuaBLOD bootloader, we skip this part here, mjan 20101227
   // Enable PLL0
-  pm_pll_enable(&AVR32_PM, 0);
-
+  //~ pm_pll_enable(&AVR32_PM, 0);
   // Wait for PLL0 locked
-  pm_wait_for_pll0_locked(&AVR32_PM);
+  //~ pm_wait_for_pll0_locked(&AVR32_PM);
 
   if (div2_cpu)
   {
@@ -194,15 +197,17 @@ int pm_configure_clocks(pm_freq_param_t 
   else
     b_div2_pba = FALSE;
 
-  pm_cksel(&AVR32_PM
-  , b_div2_pba, div2_pba // PBA
-  , b_div2_cpu, div2_cpu // PBB
-  , b_div2_cpu, div2_cpu // HSB
-  );
+	//PLL0 is already set up by the eLuaBLOD bootloader, we skip this part here, mjan 20101227
+  //~ pm_cksel(&AVR32_PM
+  //~ , b_div2_pba, div2_pba // PBA
+  //~ , b_div2_cpu, div2_cpu // PBB
+  //~ , b_div2_cpu, div2_cpu // HSB
+  //~ );
 
   if (param->cpu_f > AVR32_FLASHC_FWS_0_MAX_FREQ)
   {
-    flashc_set_wait_state(1);
+	  	//Waitstate is already set by the eLuaBLOD bootloader, we skip this part here, mjan 20101227
+    //~ flashc_set_wait_state(1);
 #if (defined AVR32_FLASHC_210_H_INCLUDED)
     if (param->cpu_f > AVR32_FLASHC_HSEN_FWS_1_MAX_FREQ)
       flashc_issue_command(AVR32_FLASHC_FCMD_CMD_HSEN, -1);
@@ -221,7 +226,8 @@ int pm_configure_clocks(pm_freq_param_t 
 #endif
   }
 
-  pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
+	//We (actually the CPU) is already running from PLL0, due to the eLuaBLOD bootloader, we skip this part here, mjan 20101227
+  //~ pm_switch_to_clock(&AVR32_PM, AVR32_PM_MCCTRL_MCSEL_PLL0);
 
   return PM_FREQ_STATUS_OK;
 }
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/src/platform/avr32/sdramc.c elua-svn/src/platform/avr32/sdramc.c
--- elua-svn.orig/src/platform/avr32/sdramc.c	2010-12-31 14:48:31.011888940 +0100
+++ elua-svn/src/platform/avr32/sdramc.c	2010-12-31 15:27:10.735888588 +0100
@@ -90,7 +90,8 @@ static void sdramc_ck_delay(unsigned lon
 /*! \brief Puts the multiplexed MCU pins used for the SDRAM under control of the
  *         SDRAMC.
  */
-#if BOARD == EVK1100 || BOARD == EVK1104 || BOARD == EVK1105 
+#if BOARD == EVK1100 || BOARD == EVK1104 || BOARD == EVK1105 \
+ || BOARD == MIZAR32
 static void sdramc_enable_muxed_pins(void)
 {
   static const gpio_map_t SDRAMC_EBI_GPIO_MAP =
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/src/platform/avr32/usart.c elua-svn/src/platform/avr32/usart.c
--- elua-svn.orig/src/platform/avr32/usart.c	2010-12-31 14:48:31.015892216 +0100
+++ elua-svn/src/platform/avr32/usart.c	2010-12-31 15:27:10.739894200 +0100
@@ -860,8 +860,13 @@ int usart_read_char(volatile avr32_usart
 int usart_getchar(volatile avr32_usart_t *usart)
 {
   int c, ret;
-
-  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY);
+	//~ int timeout = 10000;
+  while ((ret = usart_read_char(usart, &c)) == USART_RX_EMPTY) {
+	  //~ timeout--;
+	  //~ if(!timeout) {
+		//~ return USART_FAILURE;
+	//~ }
+  }
 
   if (ret == USART_RX_ERROR)
     return USART_FAILURE;
diff -pruN -x .svn -x .pc -x .sconf_temp elua-svn.orig/src/platform/lpc17xx/platform_conf.h elua-svn/src/platform/lpc17xx/platform_conf.h
--- elua-svn.orig/src/platform/lpc17xx/platform_conf.h	2010-12-31 14:48:46.179890280 +0100
+++ elua-svn/src/platform/lpc17xx/platform_conf.h	2010-12-31 15:27:10.755891708 +0100
@@ -92,7 +92,7 @@
 #define ADC_TIMER_FIRST_ID    0
 #define ADC_NUM_TIMERS        4
 
-// RPC  
+// RPC
 #define RPC_UART_ID           CON_UART_ID
 #define RPC_TIMER_ID          CON_TIMER_ID
 
@@ -115,6 +115,6 @@
 #define SRAM2_SIZE            0x8000
 #define MEM_START_ADDRESS     { ( void* )end, ( void* )SRAM2_ORIGIN }
 #define MEM_END_ADDRESS       { ( void* )( SRAM_ORIGIN + SRAM_SIZE - STACK_SIZE_TOTAL - 1 ), ( void* )( SRAM2_ORIGIN + SRAM2_SIZE - 1 ) }
- 
+
 #endif // #ifndef __PLATFORM_CONF_H__
 
